
#To list properties for 'reservation-service' stored in git config-repo folder:
http://localhost:8888/reservation-service/master

Microproxy (Zuul) 
http://localhost:9999/[reservation-service]/reservations - simply proxies to :8085/reservations
reservation-service context in this case ID of the service that was registered 
in the registry service (Eureka, Zookeeper, etc)

API gateway access endpoint specified as follows:
http://localhost:9999/reservations/names


#Make sure to include the following in app properties to expose actuator endpoints
management.endpoints.web.exposure.include=*

#to refresh props
curl -X POST http://localhost:8085/actuator/refresh

# do not forget to rename default application.properties to bootstrap.properties when using remote config service

#info
#https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka
#by Josh Long
#https://www.youtube.com/watch?v=ZyK5QrKCbwM

reservation-client
----------------
Eureka Discovery
Config Client
Hystrix - for circuit breaker
Zuul - for micro proxy
Stream Redis - for messaging microservices
Zipkin - for distributed tracesing

There are two types of "edge services":
1) Micro-proxy - blindly forwards requests behind load balancer
2) API Gateway - performs API and protocol translations

Edge service should stood up through DNS.
Smart phone or client devices cannot use Eureka for discovery. They still need to use DNS.
Devices will send request to edge service, which will mediate the request inside and 
forward it to the right service(s).
It is useful patter to let your devices to talk to one external serice only, where edge 
service will transform device requests as a middle man.

Micro-proxy (e.g. Zuul from Netflix built on RxJava) - typically is good for HTML5 apps where the connection has to stay on ceraint host:port
All it does just blindly forwards request from the Edge service to the service we have referenced it.

*****************************
List<String> x = new ArrayList<>(); // Generic type String will be removed at run-time: List x = new ArrayList();
List<String> x2 = new ArrayList<String>(){/*anonymous sub-class*/}; // now sting is a part of parent-chid hierarchy. 
//Generic type String will stay at run-time now. . It extends the list of String now, not the list of objects
// We can capture this generic type information using Type-Token pattern.
In Spring it is ParametrizedTypeReference<T>


Ribbon is the component that does load balancing in the registry service. It is programmable.
By default it uses round robin.
It can support session aware connection, sticky session aware, or whatever aware 
load balancing algorithms.

Client ap with Hystix (Circuit Breakers) will control the route to the service. If load balancer can return a service instance it is goood, but when there are no instances left, istead of failing
it will trigger circuit breaker fallback function that will return at least something.

ATTENTION: 
Distributed state synchronization - invites complexity.
Lazy architecture reaches for something easy such as Distributed Transactions.
The recomendation is to ignore simplicity at all cost.
Distributed transacation servers only to slowdown the agreagate system. 
They also not as guaranted as we migh think.

Instead it is better to use eventual consistency, such as message! If the service is down the message will be buffered and message will be delivered when service is up and running again.

Kafka, Redis, RabitMQ, etc

RabitMQ default port is 5671, console management 15672, guest:guest

Pay attention to submitting your application/json data via RequestBody - not RequestParam

Hystrix-dashboard - heartbeatsa from circuits, you can federate all streams from all circuits (see spring-turbine)
# manamgement console 
http://localhost:8010/hystrix
URL to monitor need to provide a strem of data (ping: )
http://localhost:9999/actuator/hystrix.stream


Distributed tracing is not a simple task for request coming through multiple services. 
To mitigate that we need to propagade UUID in our request continue to propagafe this UUID across all services.
spring-cloud-sleuth
zipkin is a specific implementation of the sleuth

Run zipkin from the docker container on local port 9422 whereas 9411 is internal Docker container port
docker run -d -p 9422:9411 openzipkin/zipkin
or via java
curl -sSL https://zipkin.io/quickstart.sh | bash -s
java -jar zipkin.jar
or from guthub
git clone https://github.com/openzipkin/zipkin
cd zipkin
./mvnw -DskipTests --also-make -pl zipkin-server clean install
java -jar ./zipkin-server/target/zipkin-server-*exec.jar

curl -X POST -d '{"reservationName": "Some name"}' --header "Content-Type: application/json" http://localhost:9999/reservations

@Balanced @Bean for RestTemplate allows to use service-name as the address of the service.

with Eureka disabled:
myservice.ribbon.eureka.enabled=false
Use @RibbonClient(name = "myservice") in the code and specify list of services in app .properties file as follows:
myservice.ribbon.listOfServers=localhost:9000,localhost:9100
and then use
restTemplate.getForEntity("http://myservice/api/v1/123", String.class);

Use Nginx as a front end for accesing edge services. Read this
https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/






